/*******************************************************************************
* Copyright (c) 2015 Intel Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#include "mon_defs.h"
#include "msr_defs.h"
#include "mon_arch_defs.h"
#include "mon_startup.h"
#include "xmon_desc.h"
#include "common.h"
#include "ikgtboot.h"
int run_xmon_loader(xmon_desc_t *td);

extern void __cpuid(uint64_t cpu_info[4], uint64_t info_type);

static uint64_t __readmsr(uint64_t msr_id)
{
	__asm__ __volatile__ (
		"mov %0, %%rcx\n"
		"xor %%rax, %%rax\n"
		"rdmsr\n"
		:
		: "g" (msr_id)
		: "%rcx", "%rax", "%rdx"
		);
}

int check_vmx_support(void)
{
	uint64_t info[4];
	uint64_t u;

	/* CPUID: input in rax = 1. */

	__cpuid(info, 1);

	/* CPUID: output in rcx, VT available? */

	if ((info[2] & 0x00000020) == 0) {
		return -1;
	}

	/* Fail if feature is locked and vmx is off. */

	u = __readmsr(IA32_MSR_FEATURE_CONTROL);

	if (((u & 0x01) != 0) && ((u & 0x04) == 0)) {
		return -1;
	}

	return 0;
}

/*
 * must put magic file offset mapping header in .text section
 * because the final binary is generated by "objcopy -j .text ..." to
 * strip all sections but .text
 */
const xmon_loaderbin_file_mapping_header_t file_mapping_hdr_info
__attribute__ ((section(".text#")))
__attribute__ ((aligned(4))) = {
	XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC0,      /* magic 0 */
	XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC1,      /* magic 1 */
	0,                                              /* clear flags */
	0
};


static xmon_loaderbin_file_mapping_header_t* get_file_offsets_header(uint32_t start_addr, uint32_t size)
{
	/* search the magic file offset header */
	uint32_t *tmpbuf, *starter_img_base;
	xmon_loaderbin_file_mapping_header_t *tmp_hdr;
	starter_img_base = (uint32_t *)(uint64_t)start_addr;
	for (tmpbuf = starter_img_base;
		 (uint64_t)tmpbuf < ((uint64_t)starter_img_base + size - 4);
		 tmpbuf++) {
			/* 4 byte aligned searching */
			tmp_hdr = (xmon_loaderbin_file_mapping_header_t *)tmpbuf;

			if ((tmp_hdr->magic0 ==
			     XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC0) &&
			    (tmp_hdr->magic1 ==
			     XMON_LOADERBIN_FILE_MAPPING_HEADER_MAGIC1)) {
				return (xmon_loaderbin_file_mapping_header_t *) tmp_hdr;
			}
	}
	return NULL;
}

/* Function: starter_main
* Description: Called by start() in starter.S. Jumps to xmon_loader - xmon loader.
* This function never returns back.
* Calling convention:
*   rdi, rsi, rdx, rcx, r8, r9, stack1, stack2
*/
void starter_main(uint64_t header,
           uint64_t magic,
           uint64_t rsp,
           uint64_t rbp,
           uint64_t rflags)
{
	mon_guest_cpu_startup_state_t *s;
	xmon_loaderbin_file_mapping_header_t *file_hdr;
	xmon_loader_memory_layout_t *loader_mem;
	xmon_runtime_memory_layout_t *runtime_mem;
	xmon_desc_t *xmon_desc;
	uint32_t err = 0;
	ikgt_platform_info_t * platform_info  = (ikgt_platform_info_t*)header;


	/* Find file offsets header */
	file_hdr = get_file_offsets_header(platform_info->load_addr, SCAN_MAX_IMAGE_SIZE);
	if (file_hdr == NULL)
		goto DEADLOOP;

	loader_mem = (xmon_loader_memory_layout_t *)(uint64_t)(platform_info->load_addr);

	if (check_vmx_support() != 0) {
		goto DEADLOOP;
	}

	xmon_desc = &(loader_mem->u_desc.ed);

	/* clear xmon_desc to ZEROs */
	mon_memset(xmon_desc, 0, sizeof(xmon_desc_t));

	/* assign it to xmon_desc for later reference */
	xmon_desc->loader_mem_addr = (uint64_t)loader_mem;


	/*
	 * caculate the total xmon size < use default value currently >
	 * or get it from cmdline.
	 * TODO: do a runtime xmon size estimation, if it is larger than default
	 *       value XMON_DEFAULT_TOTAL_SIZE, then return an error.
	 * could move to xmon_loader to do so.
	 */
	xmon_desc->xmon.total_size = XMON_DEFAULT_TOTAL_SIZE;

	/* get runtime_mem (xmon_runtime_memory_layout_t) address */
	runtime_mem = (xmon_runtime_memory_layout_t *)(uint64_t)(platform_info->run_addr);

	/* assign it to xmon_desc_t for later reference */
	xmon_desc->runtime_mem_addr = (uint64_t)runtime_mem;

	/* save module information (file mapped address in RAM + base location )
	 *  TODO: better to caculate what address is starter loaded by bootstub...instead of
	 *        using the hardcode address.
	 */
	if (file_hdr->files[XMON_LOADER_BIN_INDEX].size &&
	    (file_hdr->flags & INDEX_TO_BITMAP_FLAG(XMON_LOADER_BIN_INDEX))) {
		xmon_desc->xmon_loader_file.addr =
			(uint64_t)(loader_mem->u_ldr_bin.img_base) +
			file_hdr->files[
				XMON_LOADER_BIN_INDEX].offset;
		xmon_desc->xmon_loader_file.size =
			file_hdr->files[XMON_LOADER_BIN_INDEX].size;
	} else {
		goto DEADLOOP;
	}

	if (file_hdr->files[STARTAP_BIN_INDEX].size &&
	    (file_hdr->flags & INDEX_TO_BITMAP_FLAG(STARTAP_BIN_INDEX))) {
		xmon_desc->startap_file.addr = (uint64_t)(loader_mem->u_ldr_bin.img_base) +
			file_hdr->files[STARTAP_BIN_INDEX].offset;
		xmon_desc->startap_file.size = file_hdr->files[STARTAP_BIN_INDEX].size;
	} else {
		goto DEADLOOP;
	}

	if (file_hdr->files[XMON_BIN_INDEX].size &&
	    (file_hdr->flags & INDEX_TO_BITMAP_FLAG(XMON_BIN_INDEX))) {
		xmon_desc->xmon_file.addr = (uint64_t)(loader_mem->u_ldr_bin.img_base) +
			file_hdr->files[XMON_BIN_INDEX].offset;
		xmon_desc->xmon_file.size = file_hdr->files[XMON_BIN_INDEX].size;
	} else {
		goto DEADLOOP;
	}

#define RETURN_ADDRESS() (__builtin_return_address(0))
	/* save multiboot initial state */
	xmon_desc->initial_state.rax = magic;  /* boot magic */
	xmon_desc->initial_state.rbx = header;  /* boot info: setup header!*/
	xmon_desc->initial_state.rcx = 0;  /* undefined: len*/
	xmon_desc->initial_state.rdx = 0;  /* undefined */
	xmon_desc->initial_state.rflags = rflags;
	xmon_desc->initial_state.rip = (uint64_t)RETURN_ADDRESS(); /* return address of starter_main for now, update when needed*/
	xmon_desc->initial_state.rdi = 0;  /* undefined */
	xmon_desc->initial_state.rsi = 0;   /* undefined */
	xmon_desc->initial_state.rbp = rbp;   /* undefined */
	xmon_desc->initial_state.rsp = rsp;  /* undefined, here uses our own starter stack */


	err = run_xmon_loader(xmon_desc);
	if(err != 0)
		goto DEADLOOP;

DEADLOOP:
	while (1) {
	}
}
/* End of file */
